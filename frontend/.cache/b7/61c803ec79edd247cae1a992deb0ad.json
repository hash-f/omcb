{"id":"node_modules/react-use-websocket/dist/lib/attach-listener.js","dependencies":[{"name":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/attach-listener.js.map","includedInParent":true,"mtime":1732535186173},{"name":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/src/lib/attach-listener.ts","includedInParent":true,"mtime":1732535186177},{"name":"/Users/h/Developer/go-by-example/omcb/frontend/package.json","includedInParent":true,"mtime":1732535186185},{"name":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/package.json","includedInParent":true,"mtime":1732535186173},{"name":"./socket-io","loc":{"line":15,"column":26,"index":520},"parent":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/attach-listener.js","resolved":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/socket-io.js"},{"name":"./heartbeat","loc":{"line":16,"column":26,"index":562},"parent":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/attach-listener.js","resolved":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/heartbeat.js"},{"name":"./constants","loc":{"line":17,"column":26,"index":604},"parent":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/attach-listener.js","resolved":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/constants.js"},{"name":"./util","loc":{"line":18,"column":21,"index":641},"parent":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/attach-listener.js","resolved":"/Users/h/Developer/go-by-example/omcb/frontend/node_modules/react-use-websocket/dist/lib/util.js"}],"generated":{"js":"\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attachListeners = void 0;\nvar socket_io_1 = require(\"./socket-io\");\nvar heartbeat_1 = require(\"./heartbeat\");\nvar constants_1 = require(\"./constants\");\nvar util_1 = require(\"./util\");\nvar bindMessageHandler = function (webSocketInstance, optionsRef, setLastMessage, lastMessageTime) {\n    webSocketInstance.onmessage = function (message) {\n        var _a;\n        optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n        if (typeof (lastMessageTime === null || lastMessageTime === void 0 ? void 0 : lastMessageTime.current) === 'number') {\n            lastMessageTime.current = Date.now();\n        }\n        if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n            return;\n        }\n        if (optionsRef.current.heartbeat &&\n            typeof optionsRef.current.heartbeat !== \"boolean\" &&\n            ((_a = optionsRef.current.heartbeat) === null || _a === void 0 ? void 0 : _a.returnMessage) === message.data) {\n            return;\n        }\n        setLastMessage(message);\n    };\n};\nvar bindOpenHandler = function (webSocketInstance, optionsRef, setReadyState, reconnectCount, lastMessageTime) {\n    webSocketInstance.onopen = function (event) {\n        optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n        reconnectCount.current = 0;\n        setReadyState(constants_1.ReadyState.OPEN);\n        //start heart beat here\n        if (optionsRef.current.heartbeat && webSocketInstance instanceof WebSocket) {\n            var heartbeatOptions = typeof optionsRef.current.heartbeat === \"boolean\"\n                ? undefined\n                : optionsRef.current.heartbeat;\n            lastMessageTime.current = Date.now();\n            (0, heartbeat_1.heartbeat)(webSocketInstance, lastMessageTime, heartbeatOptions);\n        }\n    };\n};\nvar bindCloseHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        return function () { };\n    }\n    (0, util_1.assertIsWebSocket)(webSocketInstance, optionsRef.current.skipAssert);\n    var reconnectTimeout;\n    webSocketInstance.onclose = function (event) {\n        var _a;\n        optionsRef.current.onClose && optionsRef.current.onClose(event);\n        setReadyState(constants_1.ReadyState.CLOSED);\n        if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n            var reconnectAttempts = (_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n            if (reconnectCount.current < reconnectAttempts) {\n                var nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n                    optionsRef.current.reconnectInterval(reconnectCount.current) :\n                    optionsRef.current.reconnectInterval;\n                reconnectTimeout = window.setTimeout(function () {\n                    reconnectCount.current++;\n                    reconnect();\n                }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n            }\n            else {\n                optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n                console.warn(\"Max reconnect attempts of \".concat(reconnectAttempts, \" exceeded\"));\n            }\n        }\n    };\n    return function () { return reconnectTimeout && window.clearTimeout(reconnectTimeout); };\n};\nvar bindErrorHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n    var reconnectTimeout;\n    webSocketInstance.onerror = function (error) {\n        var _a;\n        optionsRef.current.onError && optionsRef.current.onError(error);\n        if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n            optionsRef.current.onClose && optionsRef.current.onClose(__assign(__assign({}, error), { code: 1006, reason: \"An error occurred with the EventSource: \".concat(error), wasClean: false }));\n            setReadyState(constants_1.ReadyState.CLOSED);\n            webSocketInstance.close();\n        }\n        if (optionsRef.current.retryOnError) {\n            if (reconnectCount.current < ((_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT)) {\n                var nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n                    optionsRef.current.reconnectInterval(reconnectCount.current) :\n                    optionsRef.current.reconnectInterval;\n                reconnectTimeout = window.setTimeout(function () {\n                    reconnectCount.current++;\n                    reconnect();\n                }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n            }\n            else {\n                optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts);\n                console.warn(\"Max reconnect attempts of \".concat(optionsRef.current.reconnectAttempts, \" exceeded\"));\n            }\n        }\n    };\n    return function () { return reconnectTimeout && window.clearTimeout(reconnectTimeout); };\n};\nvar attachListeners = function (webSocketInstance, setters, optionsRef, reconnect, reconnectCount, lastMessageTime, sendMessage) {\n    var setLastMessage = setters.setLastMessage, setReadyState = setters.setReadyState;\n    var interval;\n    var cancelReconnectOnClose;\n    var cancelReconnectOnError;\n    if (optionsRef.current.fromSocketIO) {\n        interval = (0, socket_io_1.setUpSocketIOPing)(sendMessage);\n    }\n    bindMessageHandler(webSocketInstance, optionsRef, setLastMessage, lastMessageTime);\n    bindOpenHandler(webSocketInstance, optionsRef, setReadyState, reconnectCount, lastMessageTime);\n    cancelReconnectOnClose = bindCloseHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n    cancelReconnectOnError = bindErrorHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n    return function () {\n        setReadyState(constants_1.ReadyState.CLOSING);\n        cancelReconnectOnClose();\n        cancelReconnectOnError();\n        webSocketInstance.close();\n        if (interval)\n            clearInterval(interval);\n    };\n};\nexports.attachListeners = attachListeners;\n"},"sourceMaps":{"js":{"version":3,"file":"attach-listener.js","sourceRoot":"","sources":["../../src/lib/attach-listener.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AACA,yCAAgD;AAChD,yCAAwC;AACxC,yCAKqB;AAErB,+BAA2C;AAO3C,IAAM,kBAAkB,GAAG,UACzB,iBAAgC,EAChC,UAAqC,EACrC,cAAyC,EACzC,eAAyC;IAEzC,iBAAiB,CAAC,SAAS,GAAG,UAAC,OAAqC;;QAClE,UAAU,CAAC,OAAO,CAAC,SAAS,IAAI,UAAU,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QAEtE,IAAI,OAAO,CAAA,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,OAAO,CAAA,KAAK,QAAQ,EAAE,CAAC;YACjD,eAAe,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvC,CAAC;QAED,IAAI,OAAO,UAAU,CAAC,OAAO,CAAC,MAAM,KAAK,UAAU,IAAI,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC;YACnG,OAAO;QACT,CAAC;QACD,IACE,UAAU,CAAC,OAAO,CAAC,SAAS;YAC5B,OAAO,UAAU,CAAC,OAAO,CAAC,SAAS,KAAK,SAAS;YACjD,CAAA,MAAA,UAAU,CAAC,OAAO,CAAC,SAAS,0CAAE,aAAa,MAAK,OAAO,CAAC,IAAI,EAC5D,CAAC;YACD,OAAO;QACT,CAAC;QAED,cAAc,CAAC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,IAAM,eAAe,GAAG,UACtB,iBAAgC,EAChC,UAAqC,EACrC,aAAuC,EACvC,cAAwC,EACxC,eAAyC;IAEzC,iBAAiB,CAAC,MAAM,GAAG,UAAC,KAAgC;QAC1D,UAAU,CAAC,OAAO,CAAC,MAAM,IAAI,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC9D,cAAc,CAAC,OAAO,GAAG,CAAC,CAAC;QAC3B,aAAa,CAAC,sBAAU,CAAC,IAAI,CAAC,CAAC;QAC/B,uBAAuB;QACvB,IAAI,UAAU,CAAC,OAAO,CAAC,SAAS,IAAI,iBAAiB,YAAY,SAAS,EAAE,CAAC;YAC3E,IAAM,gBAAgB,GACpB,OAAO,UAAU,CAAC,OAAO,CAAC,SAAS,KAAK,SAAS;gBAC/C,CAAC,CAAC,SAAS;gBACX,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,SAAS,CAAC;YACnC,eAAe,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACrC,IAAA,qBAAS,EAAC,iBAAiB,EAAE,eAAe,EAAE,gBAAgB,CAAC,CAAC;QAClE,CAAC;IAEH,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,IAAM,gBAAgB,GAAG,UACvB,iBAAgC,EAChC,UAAqC,EACrC,aAAuC,EACvC,SAAqB,EACrB,cAAwC;IAExC,IAAI,kCAAsB,IAAI,iBAAiB,YAAY,WAAW,EAAE,CAAC;QACvE,OAAO,cAAQ,CAAC,CAAC;IACnB,CAAC;IACD,IAAA,wBAAiB,EAAC,iBAAiB,EAAE,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IACpE,IAAI,gBAAwB,CAAC;IAE7B,iBAAiB,CAAC,OAAO,GAAG,UAAC,KAAiC;;QAC5D,UAAU,CAAC,OAAO,CAAC,OAAO,IAAI,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAChE,aAAa,CAAC,sBAAU,CAAC,MAAM,CAAC,CAAC;QACjC,IAAI,UAAU,CAAC,OAAO,CAAC,eAAe,IAAI,UAAU,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC;YACpF,IAAM,iBAAiB,GAAG,MAAA,UAAU,CAAC,OAAO,CAAC,iBAAiB,mCAAI,mCAAuB,CAAC;YAC1F,IAAI,cAAc,CAAC,OAAO,GAAG,iBAAiB,EAAE,CAAC;gBAC/C,IAAM,qBAAqB,GAAG,OAAO,UAAU,CAAC,OAAO,CAAC,iBAAiB,KAAK,UAAU,CAAC,CAAC;oBACxF,UAAU,CAAC,OAAO,CAAC,iBAAiB,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;oBAC9D,UAAU,CAAC,OAAO,CAAC,iBAAiB,CAAC;gBAEvC,gBAAgB,GAAG,MAAM,CAAC,UAAU,CAAC;oBACnC,cAAc,CAAC,OAAO,EAAE,CAAC;oBACzB,SAAS,EAAE,CAAC;gBACd,CAAC,EAAE,qBAAqB,aAArB,qBAAqB,cAArB,qBAAqB,GAAI,yCAA6B,CAAC,CAAC;YAC7D,CAAC;iBAAM,CAAC;gBACN,UAAU,CAAC,OAAO,CAAC,eAAe,IAAI,UAAU,CAAC,OAAO,CAAC,eAAe,CAAC,iBAAiB,CAAC,CAAC;gBAC5F,OAAO,CAAC,IAAI,CAAC,oCAA6B,iBAAiB,cAAW,CAAC,CAAC;YAC1E,CAAC;QACH,CAAC;IACH,CAAC,CAAC;IAEF,OAAO,cAAM,OAAA,gBAAgB,IAAI,MAAM,CAAC,YAAY,CAAC,gBAAgB,CAAC,EAAzD,CAAyD,CAAC;AACzE,CAAC,CAAC;AAEF,IAAM,gBAAgB,GAAG,UACvB,iBAAgC,EAChC,UAAqC,EACrC,aAAuC,EACvC,SAAqB,EACrB,cAAwC;IAExC,IAAI,gBAAwB,CAAC;IAE7B,iBAAiB,CAAC,OAAO,GAAG,UAAC,KAAiC;;QAC5D,UAAU,CAAC,OAAO,CAAC,OAAO,IAAI,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAChE,IAAI,kCAAsB,IAAI,iBAAiB,YAAY,WAAW,EAAE,CAAC;YACvE,UAAU,CAAC,OAAO,CAAC,OAAO,IAAI,UAAU,CAAC,OAAO,CAAC,OAAO,uBACnD,KAAK,KACR,IAAI,EAAE,IAAI,EACV,MAAM,EAAE,kDAA2C,KAAK,CAAE,EAC1D,QAAQ,EAAE,KAAK,IACf,CAAC;YAEH,aAAa,CAAC,sBAAU,CAAC,MAAM,CAAC,CAAC;YACjC,iBAAiB,CAAC,KAAK,EAAE,CAAC;QAC5B,CAAC;QAED,IAAI,UAAU,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;YACpC,IAAI,cAAc,CAAC,OAAO,GAAG,CAAC,MAAA,UAAU,CAAC,OAAO,CAAC,iBAAiB,mCAAI,mCAAuB,CAAC,EAAE,CAAC;gBAC/F,IAAM,qBAAqB,GAAG,OAAO,UAAU,CAAC,OAAO,CAAC,iBAAiB,KAAK,UAAU,CAAC,CAAC;oBACxF,UAAU,CAAC,OAAO,CAAC,iBAAiB,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;oBAC9D,UAAU,CAAC,OAAO,CAAC,iBAAiB,CAAC;gBAEvC,gBAAgB,GAAG,MAAM,CAAC,UAAU,CAAC;oBACnC,cAAc,CAAC,OAAO,EAAE,CAAC;oBACzB,SAAS,EAAE,CAAC;gBACd,CAAC,EAAE,qBAAqB,aAArB,qBAAqB,cAArB,qBAAqB,GAAI,yCAA6B,CAAC,CAAC;YAC7D,CAAC;iBAAM,CAAC;gBACN,UAAU,CAAC,OAAO,CAAC,eAAe,IAAI,UAAU,CAAC,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,OAAO,CAAC,iBAA2B,CAAC,CAAC;gBACzH,OAAO,CAAC,IAAI,CAAC,oCAA6B,UAAU,CAAC,OAAO,CAAC,iBAAiB,cAAW,CAAC,CAAC;YAC7F,CAAC;QACH,CAAC;IACH,CAAC,CAAC;IAEF,OAAO,cAAM,OAAA,gBAAgB,IAAI,MAAM,CAAC,YAAY,CAAC,gBAAgB,CAAC,EAAzD,CAAyD,CAAC;AACzE,CAAC,CAAC;AAEK,IAAM,eAAe,GAAG,UAC7B,iBAAgC,EAChC,OAAgB,EAChB,UAAqC,EACrC,SAAqB,EACrB,cAAwC,EACxC,eAAyC,EACzC,WAAwB;IAEhB,IAAA,cAAc,GAAoB,OAAO,eAA3B,EAAE,aAAa,GAAK,OAAO,cAAZ,CAAa;IAElD,IAAI,QAAgB,CAAC;IACrB,IAAI,sBAAkC,CAAC;IACvC,IAAI,sBAAkC,CAAC;IAEvC,IAAI,UAAU,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QACpC,QAAQ,GAAG,IAAA,6BAAiB,EAAC,WAAW,CAAC,CAAC;IAC5C,CAAC;IAED,kBAAkB,CAChB,iBAAiB,EACjB,UAAU,EACV,cAAc,EACd,eAAe,CAChB,CAAC;IAEF,eAAe,CACb,iBAAiB,EACjB,UAAU,EACV,aAAa,EACb,cAAc,EACd,eAAe,CAChB,CAAC;IAEF,sBAAsB,GAAG,gBAAgB,CACvC,iBAAiB,EACjB,UAAU,EACV,aAAa,EACb,SAAS,EACT,cAAc,CACf,CAAC;IAEF,sBAAsB,GAAG,gBAAgB,CACvC,iBAAiB,EACjB,UAAU,EACV,aAAa,EACb,SAAS,EACT,cAAc,CACf,CAAC;IAEF,OAAO;QACL,aAAa,CAAC,sBAAU,CAAC,OAAO,CAAC,CAAC;QAClC,sBAAsB,EAAE,CAAC;QACzB,sBAAsB,EAAE,CAAC;QACzB,iBAAiB,CAAC,KAAK,EAAE,CAAC;QAC1B,IAAI,QAAQ;YAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;IACxC,CAAC,CAAC;AACJ,CAAC,CAAC;AAzDW,QAAA,eAAe,mBAyD1B","sourcesContent":["import { MutableRefObject } from 'react';\nimport { setUpSocketIOPing } from './socket-io';\nimport { heartbeat } from './heartbeat';\nimport {\n  DEFAULT_RECONNECT_LIMIT,\n  DEFAULT_RECONNECT_INTERVAL_MS,\n  ReadyState,\n  isEventSourceSupported,\n} from './constants';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { assertIsWebSocket } from './util';\n\nexport interface Setters {\n  setLastMessage: (message: WebSocketEventMap['message']) => void;\n  setReadyState: (readyState: ReadyState) => void;\n}\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setLastMessage: Setters['setLastMessage'],\n  lastMessageTime: MutableRefObject<number>,\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n\n    if (typeof lastMessageTime?.current === 'number') {\n      lastMessageTime.current = Date.now();\n    }\n\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n    if (\n      optionsRef.current.heartbeat &&\n      typeof optionsRef.current.heartbeat !== \"boolean\" &&\n      optionsRef.current.heartbeat?.returnMessage === message.data\n    ) {\n      return;\n    }\n\n    setLastMessage(message);\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnectCount: MutableRefObject<number>,\n  lastMessageTime: MutableRefObject<number>,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(ReadyState.OPEN);\n    //start heart beat here\n    if (optionsRef.current.heartbeat && webSocketInstance instanceof WebSocket) {\n      const heartbeatOptions =\n        typeof optionsRef.current.heartbeat === \"boolean\"\n          ? undefined\n          : optionsRef.current.heartbeat;\n      lastMessageTime.current = Date.now();\n      heartbeat(webSocketInstance, lastMessageTime, heartbeatOptions);\n    }\n\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return () => { };\n  }\n  assertIsWebSocket(webSocketInstance, optionsRef.current.skipAssert);\n  let reconnectTimeout: number;\n\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(ReadyState.CLOSED);\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      const reconnectAttempts = optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n      if (reconnectCount.current < reconnectAttempts) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  let reconnectTimeout: number;\n\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    optionsRef.current.onError && optionsRef.current.onError(error);\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose({\n        ...error,\n        code: 1006,\n        reason: `An error occurred with the EventSource: ${error}`,\n        wasClean: false,\n      });\n\n      setReadyState(ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n\n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < (optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT)) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts as number);\n        console.warn(`Max reconnect attempts of ${optionsRef.current.reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nexport const attachListeners = (\n  webSocketInstance: WebSocketLike,\n  setters: Setters,\n  optionsRef: MutableRefObject<Options>,\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n  lastMessageTime: MutableRefObject<number>,\n  sendMessage: SendMessage\n): (() => void) => {\n  const { setLastMessage, setReadyState } = setters;\n\n  let interval: number;\n  let cancelReconnectOnClose: () => void;\n  let cancelReconnectOnError: () => void;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(\n    webSocketInstance,\n    optionsRef,\n    setLastMessage,\n    lastMessageTime\n  );\n\n  bindOpenHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnectCount,\n    lastMessageTime,\n  );\n\n  cancelReconnectOnClose = bindCloseHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  cancelReconnectOnError = bindErrorHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  return () => {\n    setReadyState(ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};\n"]}},"error":null,"hash":"02068b1ea7e318e3f04e471c83f134c6","cacheData":{"env":{}}}